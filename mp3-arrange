#!/usr/bin/env node

'use strict';

var pkg = require('./package');
var util = require('util');
var fs = require('fs-extra');
var path = require('path');

var glob = require('glob');
var async = require('async');
var bytes = require('bytes');
var winston = require('winston');

var Mp3File = require('./Mp3File');
var ProgressBar = require('./ProgressBar');

var opts = require('nomnom')
.option('source', {
  abbr: 's',
  metavar: 'DIR',
  help: 'Source directory',
  required: true,
  callback: function(dir) {
    if (!fs.existsSync(dir)) {
      return 'Source directory does not exist';
    }
  }
})
.option('destination', {
  abbr: 'd',
  metavar: 'DIR',
  help: 'Destination directory',
  required: true,
  callback: function(dir) {
    if (!fs.existsSync(dir)) {
      return 'Destination directory does not exist';
    }
  }
})
.option('logfile', {
  abbr: 'l',
  metavar: 'FILE',
  help: 'Log file',
  default: 'logs-mp3-arrange.txt'
})
.option('dry-run', {
  abbr: 'r',
  flag: true,
  default: false,
  help: 'Do a dry run, no changes will be made, and no logs files will be generated'
})
.option('skip-unknowns', {
  abbr: 'u',
  flag: true,
  default: true,
  help: 'Skip processing the file if no id3 data can be read'
})
.option('format-filenames', {
  abbr: 'f',
  flag: true,
  default: true,
  help: 'Re-name the files to match the song name'
})
.option('overwrite', {
  abbr: 'o',
  flag: true,
  default: false,
  help: 'Overwrite the destination file if it exists'
})
.option('move', {
  abbr: 'm',
  flag: true,
  default: false,
  help: 'Move the files, instead of copying'
})
.option('quiet', {
  abbr: 'q',
  flag: true,
  default: false,
  help: 'Only output errors'
})
.option('version', {
  abbr: 'v',
  flag: true,
  help: 'Print version and exit',
  default: false,
  callback: function() {
     return 'version ' + pkg.version;
  }
});

// Parse the arguments
opts = opts.parse();

// Create logger
var logger = new (winston.Logger)({
  transports: [
    new (winston.transports.File)({
      filename: opts.logfile,
    })
  ]
});

var startTime = new Date();

function echo() {
  if (!opts.quiet) {
    console.log.apply(console, arguments);
  }
}

function exit(code, msg) {
  if (msg) echo(msg);
  process.exit(code);
}

function summary() {

   var options = {
    from: startTime,
    until: new Date,
    limit: Infinity,
    start: 0,
    order: 'desc',
    fields: ['level']
  };

  logger.query(options, function (err, logs) {
    if (err) throw err;

    var errors = logs['file'].filter(function(log){
      return (log.level === 'error');
    });
    var success = logs['file'].filter(function(log){
      return (log.level === 'success');
    });

    echo('Logs:', opts.logfile);
    echo('Copied:', success.length);
    echo('Skipped:', errors.length);

    if (errors.length) {
      echo(
        'There were %d errors while copying the files, please see %s for more information.',
        errors.length,
        opts.logfile
      );
    }
  });
}

function onFindFiles(err, found) {

  process.stdout.write('done\n');
  if (err) exit(1, err);

  var totalSize = 0;
  var barMsg = '%s :current of :total [:bar] :percent ETA: :etas';

  var progressBar = new ProgressBar({
    total: found.length,
    size: 30,
    frequency: 100,
  });

  var files = found.map(function(file) {
    return new Mp3File(
      path.join(opts.source, file),
      opts,
      logger
    );
  });

  function processFile(file, done) {
    var action = opts.move ? 'move' : 'copy';
    file.process(action, opts.destination, function(err) {
      if (err) file.log('error', err);
      else file.log('success');
      progressBar.progress();
      if (file.fileSize) totalSize += file.fileSize;
      done();
    });
  }

  async.eachSeries(files, processFile, function() {
    echo('Total size:', bytes(totalSize));
    summary();
  });
}

// Handle interruptions
process.on('SIGINT', function() {
  summary();
  process.exit();
});

// Begin
process.stdout.write('Finding files...');
glob('**/*.mp3', { cwd: opts.source }, onFindFiles);
