#!/usr/bin/env node

'use strict';

var pkg = require('../package');
var util = require('util');
var fs = require('fs-extra');
var path = require('path');

var glob = require('glob');
var async = require('async');
var bytes = require('bytes');
var winston = require('winston');
var numeral = require('numeral');

var Mp3File = require('../Mp3File');
var ProgressBar = require('../ProgressBar');

var startTime = new Date();

var logger = logger = new (winston.Logger)({
  levels: {
    debug: 0,
    verbose: 1,
    info: 2,
    warn: 3,
    error: 4,
    success: 5
  }
});

var opts = require('nomnom')
.option('source', {
  abbr: 's',
  metavar: 'DIR',
  help: 'Source directory',
  required: true,
  callback: function(dir) {
    if (!fs.existsSync(dir)) {
      return 'Source directory does not exist';
    }
  }
})
.option('destination', {
  abbr: 'd',
  metavar: 'DIR',
  help: 'Destination directory',
  required: true,
  callback: function(dir) {
    if (!fs.existsSync(dir)) {
      return 'Destination directory does not exist';
    }
  }
})
.option('logfile', {
  abbr: 'l',
  metavar: 'FILE',
  help: 'Log file',
  default: 'logs-mp3-arrange.txt'
})
.option('dry-run', {
  abbr: 'r',
  flag: true,
  default: false,
  help: 'Do a dry run, no changes will be made, and no logs files will be generated'
})
.option('skip-unknowns', {
  abbr: 'u',
  flag: true,
  default: true,
  help: 'Skip processing the file if no id3 data can be read'
})
.option('format-filenames', {
  abbr: 'f',
  flag: true,
  default: true,
  help: 'Re-name the files to match the song name'
})
.option('overwrite', {
  abbr: 'o',
  flag: true,
  default: false,
  help: 'Overwrite the destination file if it exists'
})
.option('move', {
  abbr: 'm',
  flag: true,
  default: false,
  help: 'Move the files instead of copying'
})
.option('save-progress', {
  abbr: 'S',
  flag: true,
  default: false,
  help: 'Save (and resume) progress'
})
.option('quiet', {
  abbr: 'q',
  flag: true,
  default: false,
  help: 'Only output errors'
})
.option('version', {
  abbr: 'v',
  flag: true,
  help: 'Print version and exit',
  default: false,
  callback: function() {
     return 'version ' + pkg.version;
  }
});

function echo() {
  if (!opts.quiet) {
    process.stdout.write(util.format.apply(util, arguments));
  }
}

function exit(code, msg) {
  if (msg) echo(msg);
  process.exit(code);
}

function saveProgressToFile(logs) {
  var progress = {}
  logs.forEach(function(log) {
    progress[log.srcFile] = log;
  });
  var location = path.join(opts.destination, 'mp3-tools.progress.json');
  fs.writeFileSync(location, JSON.stringify(progress));
}

function readProgressFromFile() {
  var processedFiles = {};
  var progressFile = path.join(opts.destination, 'mp3-tools.progress.json');
  if (opts['save-progress'] && fs.existsSync(progressFile)) {
    try {
      processedFiles = require(path.resolve(progressFile));
      echo('NOTE: Skipping processed files in %s', progressFile);
    } catch(e) {};
  }
  return processedFiles;
}

function summary(done) {

   var options = {
    from: startTime,
    until: new Date,
    limit: Infinity,
    start: 0,
    order: 'desc',
    fields: ['level','fileSize','srcFile','destFile','message']
  };

  logger.query(options, function (err, logs) {

    if (err) throw err;
    if (opts['save-progress']) saveProgressToFile(logs.file);

    var errors = logs.file.filter(function(log){
      return (log.level === 'error');
    });
    var success = logs.file.filter(function(log){
      return (log.level === 'success');
    });

    function getTotalFileSize(prev, cur) {
      return prev + cur.fileSize;
    }

    var sourceFileSize = logs.file.reduce(getTotalFileSize, 0);
    var errorsFileSize = errors.reduce(getTotalFileSize, 0);
    var successFileSize = success.reduce(getTotalFileSize, 0);

    echo('Copied: %d (%s)', success.length, bytes(successFileSize), '\n');
    echo('Skipped: %d (%s)', errors.length, bytes(errorsFileSize), '\n');
    echo('Source size: %s', bytes(sourceFileSize), '\n');
    echo('See %s for more information.', opts.logfile, '\n');

    if (done) done();
  });
}

function onFindFiles(err, found) {

  if (!opts.quiet) process.stdout.write('done\n');
  if (err) exit(1, err);

  var processedFiles = readProgressFromFile();

  var progressBar = new ProgressBar({
    total: found.length,
    size: 30,
    frequency: 100,
    quiet: opts.quiet
  });

  var files = found.map(function(file) {
    return new Mp3File(
      path.join(opts.source, file),
      opts,
      logger
    );
  });

  function processFile(file, done) {
    if (opts['save-progress'] && (file.filePath in processedFiles)) {
      progressBar.progress();
      var processed = processedFiles[file.filePath];
      logger.log(processed.level, processed.message, processed, done);
    } else {
      var action = opts.move ? 'move' : 'copy';
      file.process(action, opts.destination, function(err) {
        progressBar.progress();
        if (err) file.log('error', err, null, done);
        else file.log('success', 'Successfully ' + (opts.move ? 'moved' : 'copied'), null, done);
      });
    }
  }

  // Handle interruptions during the copy process
  process.on('SIGINT', function() {
    progressBar.finish();
    summary(process.exit);
  });

  async.eachSeries(files, processFile, summary);
}

/***********
 * BEGIN
 ***********/

// Parse the arguments
opts = opts.parse();

// Prep logs
fs.removeSync(opts.logfile);
logger.add(winston.transports.File, {
  filename: opts.logfile,
});

if (!opts.quiet) {
  echo('\u001B[2J\u001B[0;0f'); // clear terminal
  echo('Finding files...');
}

// Find the source files
glob('**/*.mp3', { cwd: opts.source }, onFindFiles);
